# AAStar ZKP SSO

我们需要一个基于Zero Knowledge Proof的Single Sign
On(SSO)系统，首先，它是一个SSO服务；其次，它是一个开源框架，可以被任何人使用。同时它依赖的是中心化或者去中心化的credential凭证服务，可配置。
另外，SSO是一个接入到链上合约的验证系统，计算量在前端和链上，以及部署SSO的节点。
SSO就是证明我是我的一个验证过程，证明之后，就拥有了一个Session
Key（或者其他），这个Session
Key可以用于后续的交易，或者支付，或者其他业务场景。考虑隐私保护问题，还需要支持ZKP。

## 背景

主要是想通过SSO，来划分整体系统的架构。SSO相对于入口流量的管理和分配，而下游底层是服务（系统和业务）、资源（内部外部）、数据（链上链下，存储，并发和同步）是系统的核心，得益于DApp的特征，很多时候，DApp是一个皮肤，但引入边缘计算和雨计算后，DApp的计算量和数据量会越来越大。
我们假设AirAccount已经解决了证明我是我的问题：帮助任何人无许可的创建自己的凭证，并且基于凭证，帮助他们创建自己的加密账户。
那如何验证你拥有凭证给DApp看，然后基于你出示的凭证，DApp帮你完成相关业务。

## 流程

1. 以Google 账户登录为例，当我使用google account绑定并生成了一个Web3
   账户后（使用AirAccount的去中心化服务，基于你的keypair加密记录），我需要使用我的加密账户或者Google账户登录到其他应用或者网站，然后调用我的Web3账户的能力，例如提供地址给活动方获得NFT领取资格，或者活动的积分奖励；当然可能还会有更复杂的例如利用AI来调用你账户的资产进行投资等等。
2. 但是，我希望我的Google账户和Web3账户之间，是无关的，只有经过我指纹解密的操作行为，才会知道二者的绑定关系，其他人，即便是创建我绑定关系的数据库和服务，也无法得知。目前AirAccount做到了Web3账户的加密，但这不够。当我暴露两个信息给某个应用的时候，自然就产生了关联，这不是我想要的，我需要隐私。
3. 这就需要有一个ZKP
   SSO服务，既可以让你的Google账户的登录，又不暴露二者的关系。简单说，Google账户提交给SSO，SSO不暴露服务器存储的绑定关联信息，又证明你拥有一个Web3有效账户，提供给有效的ENS和Web3账户地址，这就是ZKP。
4. 当DApp作为应用时，希望的是你来提供你的ens或者钱包账户地址，而不是更私密的Google
   Account，因此SSO服务需要提供一个流程，保障任何DApp可以集成这个ZKP
   SSO服务，然后此服务在不暴露你的Google
   Account信息的情况下，提供你的ens或者钱包账户地址给DApp。这个可能是DApp需要的场景。
5. 当然，有人不介意这种关系的暴露，但我们的SSO服务不提供这种关系的暴露：按Google
   account查询对应的ens或者钱包地址。
6. 为避免社会工程学攻击，ens最好和你的google account没有名字或者意义相近的关联。
7. 为避免服务器作恶或者泄露信息，SSO服务是运行在雨计算之上的服务，服务你的是可能任意一个计算节点，基于其TEE
   OS，提供可验证不可篡改代码的，指定逻辑的服务：不存储Google
   account，查询加密后的Web3 account，然后基于你的passkey解密 ens或者Web3
   account地址给DApp。

常规支持 TEE（Trusted Execution Environment）标准的安全芯片，在内置生成 keypair
算法方面，通常会支持以下几种主流的**公钥加密算法**：

1. **椭圆曲线密码学 (ECC - Elliptic Curve Cryptography)**：
   - **ECDSA (Elliptic Curve Digital Signature
     Algorithm)**：用于生成数字签名，是 Passkey/WebAuthn
     标准中强烈推荐的算法，尤其基于 **P-256 (secp256r1)** 和 **P-384
     (secp384r1)** 曲线。TEE 安全芯片通常会内置高效且安全的 ECDSA 实现。
   - **ECDH (Elliptic Curve Diffie-Hellman)**：用于密钥交换，虽然
     Passkey/WebAuthn 的核心是签名，但在某些相关或扩展应用中，TEE 可能也会支持
     ECDH 用于建立安全通道。

2. **RSA (Rivest–Shamir–Adleman)**：
   - RSA
     算法也经常被安全芯片支持用于生成和管理密钥对，主要用于数字签名和加密。TEE
     可以提供安全的 RSA 密钥生成和操作环境。
   - 通常支持不同长度的 RSA 密钥，例如 2048 位、3072 位等。

**需要注意的是：**

- **标准和规范：** 支持 TEE 标准的芯片通常会遵循一些行业规范，例如
  GlobalPlatform 等，这些规范可能会推荐或要求支持特定的加密算法。
- **芯片型号和制造商：**
  不同的安全芯片型号和制造商可能会在支持的算法上有所差异。一些高端芯片可能会支持更多的加密算法。
- **性能优化：** TEE
  内置的算法实现通常会进行硬件级别的优化，以提高密钥生成和签名/验证等操作的性能。
- **安全性考量：** TEE
  的设计目标是提供一个隔离且安全的环境来执行敏感操作，包括密钥生成。内置的算法实现会采取各种安全措施来防止密钥泄露和篡改。

**总结来说，常规支持 TEE 标准的安全芯片，在内置生成 keypair
算法方面，最常见且核心的支持是 ECDSA（尤其是 P-256），同时 RSA
也是一种广泛支持的选项。**
具体支持哪些算法以及其性能和安全特性，需要参考具体的安全芯片规格和文档。
